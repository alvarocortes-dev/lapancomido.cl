---
phase: 07-historial-consultas
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/database/prisma/schema.prisma
  - apps/api/src/controllers/consultations.controller.js
  - apps/api/src/routes/store.routes.js
  - apps/api/src/routes/admin.routes.js
  - apps/web/src/components/selection/QuotationModal.jsx
autonomous: true

must_haves:
  truths:
    - "Cada cotización WhatsApp se guarda en BD al hacer click en botón"
    - "Si guardado falla, WhatsApp abre igual (no-blocking)"
    - "Consulta almacena snapshot de nombre/precio de productos"
  artifacts:
    - path: "packages/database/prisma/schema.prisma"
      provides: "consultations y consultation_items models"
      contains: "model consultations"
    - path: "apps/api/src/controllers/consultations.controller.js"
      provides: "saveConsultation controller"
      exports: ["saveConsultation"]
    - path: "apps/api/src/routes/store.routes.js"
      provides: "POST /api/store/consultation endpoint"
      contains: "router.post.*consultation"
  key_links:
    - from: "apps/web/src/components/selection/QuotationModal.jsx"
      to: "/api/store/consultation"
      via: "fetch fire-and-forget before WhatsApp open"
      pattern: "fetch.*store/consultation"
    - from: "apps/api/src/controllers/consultations.controller.js"
      to: "prisma.consultations.create"
      via: "Prisma nested create with items"
      pattern: "prisma\\.consultations\\.create"
---

<objective>
Implementar modelo de datos y API para guardar consultas WhatsApp automáticamente.

Purpose: Cada vez que un cliente envía una cotización por WhatsApp, los datos se guardan en BD para que el admin pueda revisarlos después.

Output: Schema con tablas consultations/consultation_items, endpoint POST para guardar, QuotationModal modificado para fire-and-forget save.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-historial-consultas/07-CONTEXT.md
@.planning/phases/07-historial-consultas/07-RESEARCH.md

# Source files
@packages/database/prisma/schema.prisma
@apps/api/src/routes/store.routes.js
@apps/web/src/components/selection/QuotationModal.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema consultations + consultation_items</name>
  <files>packages/database/prisma/schema.prisma</files>
  <action>
Add two new models at the end of schema.prisma (after authentication models):

```prisma
// ============================================
// Consultation History Models
// ============================================

model consultations {
  id             Int       @id @default(autoincrement())
  customer_name  String
  customer_phone String    // E.164 format with country code
  total_amount   Decimal   @db.Decimal(10, 2)
  product_count  Int       // Cached count for list display
  created_at     DateTime  @default(now())

  // Relations
  items consultation_items[]

  @@schema("pancomido")
}

model consultation_items {
  id              Int     @id @default(autoincrement())
  consultation_id Int
  product_id      Int     // Reference only, no FK constraint (products may be deleted)
  product_name    String  // Snapshot at consultation time
  unit_price      Decimal @db.Decimal(10, 2) // Snapshot at consultation time
  quantity        Int
  subtotal        Decimal @db.Decimal(10, 2) // qty × unit_price

  // Relations
  consultation consultations @relation(fields: [consultation_id], references: [id], onDelete: Cascade)

  @@schema("pancomido")
}
```

Note: No FK from consultation_items.product_id to products - products may be deleted but historical data must remain. The snapshot columns (product_name, unit_price) are the source of truth for display.

Run `npx prisma db push` from packages/database to sync schema.
  </action>
  <verify>
```bash
cd packages/database && npx prisma db push --accept-data-loss
```
Schema syncs without errors. Tables exist in pancomido schema.
  </verify>
  <done>
- consultations table exists with id, customer_name, customer_phone, total_amount, product_count, created_at
- consultation_items table exists with snapshot columns and FK to consultations
  </done>
</task>

<task type="auto">
  <name>Task 2: API endpoint to save consultation</name>
  <files>
apps/api/src/controllers/consultations.controller.js
apps/api/src/routes/store.routes.js
  </files>
  <action>
Create `apps/api/src/controllers/consultations.controller.js`:

```javascript
// src/controllers/consultations.controller.js
import { prisma } from '@lapancomido/database';

/**
 * Save consultation from customer quotation (public endpoint)
 * Fire-and-forget from frontend - should be fast and never block WhatsApp flow
 */
export const saveConsultation = async (req, res, next) => {
  try {
    const { customerName, customerPhone, products } = req.body;

    // Basic validation
    if (!customerName || !customerPhone || !Array.isArray(products) || products.length === 0) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    // Build items with calculated subtotals
    const items = products.map(p => ({
      product_id: p.productId,
      product_name: p.productName,
      unit_price: p.unitPrice,
      quantity: p.quantity,
      subtotal: Number(p.unitPrice) * Number(p.quantity)
    }));

    // Calculate totals
    const totalAmount = items.reduce((sum, item) => sum + Number(item.subtotal), 0);
    const productCount = items.length;

    // Create consultation with nested items
    const consultation = await prisma.consultations.create({
      data: {
        customer_name: customerName.trim(),
        customer_phone: customerPhone.trim(),
        total_amount: totalAmount,
        product_count: productCount,
        items: {
          create: items
        }
      }
    });

    res.status(201).json({ id: consultation.id });
  } catch (error) {
    next(error);
  }
};
```

Add route to `apps/api/src/routes/store.routes.js`:

```javascript
import * as consultationsController from '../controllers/consultations.controller.js';

// After existing routes, add:
router.post('/consultation', consultationsController.saveConsultation);
```

Note: This is a PUBLIC endpoint (no auth) - it's called from the customer-facing web app before WhatsApp opens.
  </action>
  <verify>
```bash
curl -X POST http://localhost:3000/api/store/consultation \
  -H "Content-Type: application/json" \
  -d '{"customerName":"Test","customerPhone":"+56 912345678","products":[{"productId":1,"productName":"Pan","unitPrice":1500,"quantity":2}]}'
```
Returns `{"id": N}` with 201 status.
  </verify>
  <done>
- POST /api/store/consultation creates consultation with items
- Returns consultation ID on success
- Returns 400 if missing required fields
  </done>
</task>

<task type="auto">
  <name>Task 3: QuotationModal fire-and-forget save</name>
  <files>apps/web/src/components/selection/QuotationModal.jsx</files>
  <action>
Modify QuotationModal.jsx to save consultation before opening WhatsApp:

1. Add `saveConsultation` function (similar to existing `saveCustomerLead`):

```javascript
const saveConsultation = async (data) => {
  try {
    await fetch(`${import.meta.env.VITE_API_URL}/api/store/consultation`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(data)
    });
  } catch (error) {
    // Don't block WhatsApp flow if save fails - silent failure
    console.error("Failed to save consultation:", error);
  }
};
```

2. In `handleSubmit`, before opening WhatsApp (after the existing `saveCustomerLead()` call), add fire-and-forget call:

```javascript
// Build consultation data for history
const consultationData = {
  customerName: form.name.trim(),
  customerPhone: fullPhone,
  products: selection.map(item => ({
    productId: item.id,
    productName: item.product,
    unitPrice: Number(item.price),
    quantity: item.quantity
  }))
};

// Fire and forget - save consultation for history (don't await)
saveConsultation(consultationData);
```

Both saves (lead + consultation) happen in parallel before WhatsApp opens. Neither blocks the flow.
  </action>
  <verify>
1. Start dev server: `npm run dev`
2. Select products in catalog
3. Open quotation modal, fill form, click submit
4. Verify WhatsApp opens immediately
5. Check DB: `SELECT * FROM pancomido.consultations ORDER BY created_at DESC LIMIT 1;`
  </verify>
  <done>
- QuotationModal saves consultation data before WhatsApp opens
- Save is non-blocking (fire-and-forget)
- Products stored with snapshot of name/price
- Customer name and phone captured
  </done>
</task>

</tasks>

<verification>
1. Schema has consultations and consultation_items tables
2. POST /api/store/consultation works and creates records
3. QuotationModal saves consultation on submit without blocking WhatsApp
4. Saved consultations include product snapshots (name, price)
5. Network errors don't prevent WhatsApp from opening
</verification>

<success_criteria>
- Every quotation WhatsApp click saves consultation to BD
- Consultation includes: customer name, phone, date, products with snapshots
- Save failure does not block WhatsApp flow
- API runs in < 200ms typical response time
</success_criteria>

<output>
After completion, create `.planning/phases/07-historial-consultas/07-01-SUMMARY.md`
</output>
