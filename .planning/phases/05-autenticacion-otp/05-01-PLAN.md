---
phase: 05-autenticacion-otp
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/database/prisma/schema.prisma
  - packages/database/prisma/seed.js
  - packages/database/package.json
  - apps/api/src/controllers/auth.controller.js
  - apps/api/src/routes/auth.routes.js
  - apps/api/src/routes/routes.js
autonomous: true

must_haves:
  truths:
    - "Existen 2 usuarios predefinidos (dev y admin) en la base de datos"
    - "Usuario puede hacer login con username y password"
    - "Primer login detecta que requiere setup de password y email"
  artifacts:
    - path: "packages/database/prisma/schema.prisma"
      provides: "users, otp_tokens, trusted_devices models"
      contains: "model users"
    - path: "packages/database/prisma/seed.js"
      provides: "Seed script para crear usuarios predefinidos"
      contains: "upsert"
    - path: "apps/api/src/controllers/auth.controller.js"
      provides: "Login endpoint con detección de setupRequired"
      exports: ["login", "setupPassword"]
    - path: "apps/api/src/routes/auth.routes.js"
      provides: "Rutas de autenticación"
      contains: "/login"
  key_links:
    - from: "apps/api/src/controllers/auth.controller.js"
      to: "packages/database"
      via: "prisma.users.findUnique"
      pattern: "prisma\\.users\\.(findUnique|update)"
    - from: "apps/api/src/routes/routes.js"
      to: "apps/api/src/routes/auth.routes.js"
      via: "app.use('/auth')"
      pattern: "authRoutes"
---

<objective>
Crear la base de datos para autenticación admin y el flujo de login básico

Purpose: Establecer los modelos de datos y endpoints iniciales para que el sistema reconozca usuarios predefinidos y detecte cuando necesitan configurar su contraseña por primera vez.

Output:
- 3 nuevos modelos Prisma (users, otp_tokens, trusted_devices)
- Script de seed para usuarios dev y admin
- Endpoint POST /auth/login con detección de setupRequired
- Endpoint POST /auth/setup-password para primer login
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-autenticacion-otp/05-RESEARCH.md
@packages/database/prisma/schema.prisma
@apps/api/src/middlewares/validateToken.js
@apps/api/src/middlewares/isAdmin.js
@apps/api/src/controllers/contact.controller.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Agregar modelos de autenticación al schema Prisma</name>
  <files>
    packages/database/prisma/schema.prisma
    packages/database/package.json
  </files>
  <action>
Agregar 3 modelos al final del schema.prisma (después de quotation_leads):

1. **model users** con campos:
   - id: Int @id @default(autoincrement())
   - username: String @unique (para "dev" y "admin")
   - email: String? @unique
   - passwordHash: String?
   - role: String @default("admin") -- valores: "admin" o "developer"
   - passwordSetupRequired: Boolean @default(true)
   - createdAt: DateTime @default(now())
   - updatedAt: DateTime @default(now()) @updatedAt
   - Relaciones: otpTokens otp_tokens[], trustedDevices trusted_devices[]
   - @@schema("pancomido")

2. **model otp_tokens** con campos:
   - id: Int @id @default(autoincrement())
   - userId: Int
   - hashedCode: String
   - expiresAt: DateTime
   - used: Boolean @default(false)
   - createdAt: DateTime @default(now())
   - Relación: user users @relation(fields: [userId], references: [id], onDelete: Cascade)
   - @@index([userId, used, expiresAt])
   - @@schema("pancomido")

3. **model trusted_devices** con campos:
   - id: Int @id @default(autoincrement())
   - userId: Int
   - deviceToken: String @unique
   - userAgent: String?
   - ipAddress: String?
   - expiresAt: DateTime
   - lastUsedAt: DateTime @default(now())
   - createdAt: DateTime @default(now())
   - Relación: user users @relation(fields: [userId], references: [id], onDelete: Cascade)
   - @@index([userId, deviceToken])
   - @@schema("pancomido")

Agregar en package.json el script "seed": "node prisma/seed.js" y la key "prisma": { "seed": "node prisma/seed.js" }

IMPORTANTE: Instalar uuid en packages/database:
```bash
cd packages/database && npm install uuid
```

Luego ejecutar:
```bash
npx prisma generate
npx prisma db push
```
  </action>
  <verify>
```bash
cd packages/database && npx prisma db push --accept-data-loss 2>&1 | grep -E "(created|Your database is now in sync)"
```
Debe mostrar que la base de datos está sincronizada y los modelos fueron creados.
  </verify>
  <done>Los modelos users, otp_tokens, y trusted_devices existen en la base de datos y el Prisma client está regenerado.</done>
</task>

<task type="auto">
  <name>Task 2: Crear seed script para usuarios predefinidos</name>
  <files>
    packages/database/prisma/seed.js
  </files>
  <action>
Crear archivo seed.js con:

```javascript
const { PrismaClient } = require('../src/generated/client');
const prisma = new PrismaClient();

async function main() {
  console.log('Seeding predefined users...');
  
  const devUser = await prisma.users.upsert({
    where: { username: 'dev' },
    update: {},
    create: {
      username: 'dev',
      role: 'developer',
      passwordSetupRequired: true
    }
  });
  
  const adminUser = await prisma.users.upsert({
    where: { username: 'admin' },
    update: {},
    create: {
      username: 'admin',
      role: 'admin',
      passwordSetupRequired: true
    }
  });
  
  console.log('Seeded users:', { 
    dev: { id: devUser.id, username: devUser.username, role: devUser.role },
    admin: { id: adminUser.id, username: adminUser.username, role: adminUser.role }
  });
}

main()
  .then(async () => {
    await prisma.$disconnect();
  })
  .catch(async (e) => {
    console.error('Seed error:', e);
    await prisma.$disconnect();
    process.exit(1);
  });
```

Ejecutar el seed:
```bash
cd packages/database && npm run seed
```
  </action>
  <verify>
```bash
cd packages/database && npm run seed 2>&1 | grep -E "Seeded users"
```
Debe mostrar los 2 usuarios creados con sus IDs.
  </verify>
  <done>Usuarios "dev" (role: developer) y "admin" (role: admin) existen en la base de datos con passwordSetupRequired: true.</done>
</task>

<task type="auto">
  <name>Task 3: Crear controller y rutas de autenticación básica</name>
  <files>
    apps/api/src/controllers/auth.controller.js
    apps/api/src/routes/auth.routes.js
    apps/api/src/routes/routes.js
  </files>
  <action>
**Crear auth.controller.js:**

```javascript
// src/controllers/auth.controller.js
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const prisma = require('@lapancomido/database');

const SALT_ROUNDS = 10;
const JWT_EXPIRY = '30d';

/**
 * POST /auth/login
 * Handles login with username/password
 * Returns setupRequired: true if first login
 */
const login = async (req, res) => {
  try {
    const { username, password } = req.body;
    
    if (!username) {
      return res.status(400).json({ error: 'Username requerido' });
    }
    
    const user = await prisma.users.findUnique({
      where: { username }
    });
    
    if (!user) {
      return res.status(401).json({ error: 'Credenciales inválidas' });
    }
    
    // First-time setup required
    if (user.passwordSetupRequired) {
      return res.status(200).json({
        setupRequired: true,
        username: user.username,
        message: 'Primer inicio de sesión - configura tu email y contraseña'
      });
    }
    
    // Normal login - verify password
    if (!password) {
      return res.status(400).json({ error: 'Contraseña requerida' });
    }
    
    const isValid = await bcrypt.compare(password, user.passwordHash);
    if (!isValid) {
      return res.status(401).json({ error: 'Credenciales inválidas' });
    }
    
    // For now, return success - OTP flow will be added in Plan 02
    // TODO: Check device trust and potentially require OTP
    const token = jwt.sign(
      { 
        userId: user.id, 
        role: user.role, 
        email: user.email,
        username: user.username
      },
      process.env.JWT_SECRET,
      { expiresIn: JWT_EXPIRY }
    );
    
    res.status(200).json({
      success: true,
      token,
      user: {
        id: user.id,
        username: user.username,
        email: user.email,
        role: user.role
      }
    });
    
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
};

/**
 * POST /auth/setup-password
 * First-time setup: set email and password
 */
const setupPassword = async (req, res) => {
  try {
    const { username, email, password } = req.body;
    
    if (!username || !email || !password) {
      return res.status(400).json({ 
        error: 'Username, email y password son requeridos' 
      });
    }
    
    // Validate email format
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({ error: 'Email inválido' });
    }
    
    // Validate password strength (min 8 chars)
    if (password.length < 8) {
      return res.status(400).json({ 
        error: 'La contraseña debe tener al menos 8 caracteres' 
      });
    }
    
    const user = await prisma.users.findUnique({
      where: { username }
    });
    
    if (!user) {
      return res.status(401).json({ error: 'Usuario no encontrado' });
    }
    
    if (!user.passwordSetupRequired) {
      return res.status(400).json({ 
        error: 'Este usuario ya tiene contraseña configurada' 
      });
    }
    
    // Check if email is already in use by another user
    const existingEmail = await prisma.users.findUnique({
      where: { email }
    });
    if (existingEmail && existingEmail.id !== user.id) {
      return res.status(400).json({ error: 'Este email ya está en uso' });
    }
    
    // Hash password and update user
    const passwordHash = await bcrypt.hash(password, SALT_ROUNDS);
    
    await prisma.users.update({
      where: { id: user.id },
      data: {
        email,
        passwordHash,
        passwordSetupRequired: false
      }
    });
    
    // Generate token for immediate login
    const token = jwt.sign(
      { 
        userId: user.id, 
        role: user.role, 
        email,
        username: user.username
      },
      process.env.JWT_SECRET,
      { expiresIn: JWT_EXPIRY }
    );
    
    res.status(200).json({
      success: true,
      token,
      user: {
        id: user.id,
        username: user.username,
        email,
        role: user.role
      },
      message: 'Contraseña configurada exitosamente'
    });
    
  } catch (error) {
    console.error('Setup password error:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
};

module.exports = {
  login,
  setupPassword
};
```

**Crear auth.routes.js:**

```javascript
// src/routes/auth.routes.js
const express = require('express');
const router = express.Router();
const authController = require('../controllers/auth.controller');

// POST /auth/login - Login with username/password
router.post('/login', authController.login);

// POST /auth/setup-password - First-time password setup
router.post('/setup-password', authController.setupPassword);

module.exports = router;
```

**Actualizar routes.js** para incluir las rutas de auth:

Agregar al inicio con los otros requires:
```javascript
const authRoutes = require('./auth.routes');
```

Agregar antes de los otros app.use():
```javascript
app.use('/auth', authRoutes);
```
  </action>
  <verify>
```bash
# Start API in background and test login endpoint
cd apps/api && timeout 5 npm run dev &
sleep 3
curl -s -X POST http://localhost:3000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"dev"}' | grep -E "(setupRequired|error)"
pkill -f "node.*api" 2>/dev/null || true
```
Debe retornar `{"setupRequired":true,...}` indicando que el usuario necesita configurar su contraseña.
  </verify>
  <done>
- POST /auth/login retorna setupRequired:true para usuarios sin contraseña
- POST /auth/login valida credenciales para usuarios con contraseña
- POST /auth/setup-password permite configurar email y contraseña en primer login
  </done>
</task>

</tasks>

<verification>
```bash
# Verify database models exist
cd packages/database && npx prisma db pull --print 2>&1 | grep -E "model (users|otp_tokens|trusted_devices)"

# Verify seed ran successfully
cd packages/database && node -e "
const prisma = require('./src/generated/client');
const p = new prisma.PrismaClient();
p.users.findMany().then(u => {
  console.log('Users in DB:', u.length);
  u.forEach(x => console.log('  -', x.username, x.role, 'setupRequired:', x.passwordSetupRequired));
  p.\$disconnect();
}).catch(e => { console.error(e); p.\$disconnect(); });
"

# Verify auth routes registered
grep -r "authRoutes" apps/api/src/routes/routes.js
```
</verification>

<success_criteria>
1. Prisma schema tiene modelos users, otp_tokens, trusted_devices
2. Base de datos tiene 2 usuarios: dev (developer) y admin (admin), ambos con passwordSetupRequired: true
3. POST /auth/login con username "dev" retorna {setupRequired: true}
4. POST /auth/setup-password actualiza el usuario y retorna JWT token
</success_criteria>

<output>
After completion, create `.planning/phases/05-autenticacion-otp/05-01-SUMMARY.md`
</output>
