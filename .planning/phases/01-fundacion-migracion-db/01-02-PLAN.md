---
phase: 01-fundacion-migracion-db
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/database/package.json
  - packages/database/prisma/schema.prisma
  - packages/database/prisma/migrations/0_init/migration.sql
  - packages/database/src/client.ts
  - packages/database/src/index.ts
  - apps/api/src/models/Product.js
  - apps/api/src/models/User.js
  - apps/api/src/models/Auth.js
autonomous: true

must_haves:
  truths:
    - "Prisma conecta exitosamente a Supabase con schema pancomido"
    - "Todas las queries existentes de Product, User, Auth funcionan idénticamente con Prisma"
    - "prisma generate produce cliente tipado sin errores"
  artifacts:
    - path: "packages/database/prisma/schema.prisma"
      provides: "Schema Prisma generado por introspección"
      contains: "@@schema(\"pancomido\")"
    - path: "packages/database/src/client.ts"
      provides: "Cliente Prisma configurado para Supabase"
      contains: "PrismaClient"
    - path: "packages/database/prisma/migrations/0_init/migration.sql"
      provides: "Migración baseline marcada como aplicada"
      min_lines: 10
  key_links:
    - from: "apps/api/src/models/Product.js"
      to: "@lapancomido/database"
      via: "import prisma client"
      pattern: "import.*@lapancomido/database"
    - from: "packages/database/src/client.ts"
      to: "process.env.DATABASE_URL"
      via: "connection string"
      pattern: "DATABASE_URL|DIRECT_URL"
---

<objective>
Migrar de raw SQL (pg) a Prisma ORM usando introspección del schema existente en Supabase.

Purpose: Obtener type-safety, migraciones controladas, y mejor DX manteniendo paridad exacta con queries actuales.
Output: Schema Prisma funcional, cliente configurado, y modelos API migrados a usar Prisma.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-fundacion-migracion-db/01-RESEARCH.md
@.planning/phases/01-fundacion-migracion-db/01-01-SUMMARY.md

# Código existente a migrar
@apps/api/src/config/db.js
@apps/api/src/models/Product.js
@apps/api/src/models/User.js
@apps/api/src/models/Auth.js
@apps/api/src/models/Address.js
@apps/api/src/models/Favorites.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configurar Prisma e introspección de schema</name>
  <files>
    packages/database/package.json
    packages/database/prisma/schema.prisma
    packages/database/prisma.config.ts
    packages/database/.env.example
  </files>
  <action>
1. **Actualizar packages/database/package.json para Prisma:**
   ```json
   {
     "name": "@lapancomido/database",
     "version": "0.0.0",
     "private": true,
     "main": "./src/index.ts",
     "types": "./src/index.ts",
     "exports": {
       ".": "./src/index.ts",
       "./client": "./src/client.ts"
     },
     "scripts": {
       "generate": "prisma generate",
       "db:pull": "prisma db pull",
       "db:push": "prisma db push",
       "db:migrate": "prisma migrate dev",
       "postinstall": "prisma generate"
     },
     "dependencies": {
       "@prisma/adapter-pg": "^7.3.0",
       "@prisma/client": "^7.3.0",
       "pg": "^8.13.1"
     },
     "devDependencies": {
       "prisma": "^7.3.0",
       "dotenv": "^16.4.7",
       "typescript": "^5.3.0"
     }
   }
   ```

2. **Crear packages/database/.env.example:**
   ```env
   # Pooled connection (Supavisor) - for runtime queries
   DATABASE_URL="postgres://postgres.[project]:[password]@aws-0-[region].pooler.supabase.com:6543/postgres?pgbouncer=true&schema=pancomido"
   
   # Direct connection - for CLI (migrations, introspection)
   DIRECT_URL="postgresql://postgres:[password]@db.[project].supabase.co:5432/postgres?schema=pancomido"
   ```

3. **Crear packages/database/prisma.config.ts (Prisma 7+):**
   ```typescript
   import 'dotenv/config'
   import { defineConfig, env } from 'prisma/config'
   
   export default defineConfig({
     schema: 'prisma/schema.prisma',
     datasource: {
       // Direct connection for CLI operations
       url: env('DIRECT_URL'),
     },
   })
   ```

4. **Inicializar Prisma y hacer introspección:**
   ```bash
   cd packages/database
   npx prisma init
   ```
   
   Esto crea `prisma/schema.prisma` base. Luego:
   ```bash
   # Asegurar que .env tiene DIRECT_URL configurado
   npx prisma db pull
   ```
   
   El schema generado debería incluir todas las tablas del schema `pancomido`:
   - products
   - users
   - roles
   - stock
   - (otras tablas existentes)

5. **Revisar y ajustar schema generado:**
   - Verificar que cada modelo tiene `@@schema("pancomido")`
   - Verificar nombres de campos (Prisma puede renombrar)
   - Agregar relaciones si no fueron detectadas

6. **Ejemplo de schema esperado (post-introspección):**
   ```prisma
   generator client {
     provider = "prisma-client-js"
     output   = "../src/generated/client"
   }
   
   datasource db {
     provider = "postgresql"
     url      = env("DATABASE_URL")
   }
   
   model products {
     id          Int       @id @default(autoincrement())
     product     String
     ingredients String?
     price       Decimal   @db.Decimal(10, 2)
     weight      String?
     description String?
     nutrition   String?
     available   Boolean   @default(false)
     created_at  DateTime  @default(now())
     updated_at  DateTime  @updatedAt
   
     @@map("products")
     @@schema("pancomido")
   }
   
   // ... otros modelos
   ```

IMPORTANTE: El schema exacto vendrá de la introspección. NO inventar campos.
  </action>
  <verify>
    - `cat packages/database/prisma/schema.prisma` muestra modelos
    - `grep -c "@@schema" packages/database/prisma/schema.prisma` retorna número > 0
    - `npx prisma validate` (desde packages/database) no muestra errores
  </verify>
  <done>
    - Prisma inicializado en packages/database
    - Schema introspectado desde Supabase
    - Todos los modelos tienen @@schema("pancomido")
    - prisma.config.ts configurado con DIRECT_URL
  </done>
</task>

<task type="auto">
  <name>Task 2: Crear baseline migration y cliente Prisma</name>
  <files>
    packages/database/prisma/migrations/0_init/migration.sql
    packages/database/src/client.ts
    packages/database/src/index.ts
    packages/database/tsconfig.json
  </files>
  <action>
1. **Crear baseline migration:**
   ```bash
   cd packages/database
   mkdir -p prisma/migrations/0_init
   
   # Generar SQL de la diferencia desde vacío al schema actual
   npx prisma migrate diff \
     --from-empty \
     --to-schema prisma/schema.prisma \
     --script > prisma/migrations/0_init/migration.sql
   
   # Marcar como ya aplicada (porque la DB ya existe)
   npx prisma migrate resolve --applied 0_init
   ```

2. **Generar cliente Prisma:**
   ```bash
   npx prisma generate
   ```
   Esto crea el cliente en `src/generated/client/`

3. **Crear packages/database/tsconfig.json:**
   ```json
   {
     "compilerOptions": {
       "target": "ES2020",
       "module": "NodeNext",
       "moduleResolution": "NodeNext",
       "esModuleInterop": true,
       "strict": true,
       "skipLibCheck": true,
       "outDir": "./dist",
       "rootDir": "./src",
       "declaration": true
     },
     "include": ["src/**/*"],
     "exclude": ["node_modules", "dist"]
   }
   ```

4. **Crear packages/database/src/client.ts:**
   ```typescript
   import { PrismaClient } from './generated/client'
   import { PrismaPg } from '@prisma/adapter-pg'
   import pg from 'pg'
   
   const { Pool } = pg
   
   // Create connection pool for Supabase pooler
   const pool = new Pool({
     connectionString: process.env.DATABASE_URL,
   })
   
   // Create Prisma adapter
   const adapter = new PrismaPg(pool)
   
   // Singleton pattern for Prisma client
   const globalForPrisma = globalThis as unknown as {
     prisma: PrismaClient | undefined
   }
   
   export const prisma = globalForPrisma.prisma ?? new PrismaClient({
     adapter,
     log: process.env.NODE_ENV === 'development' 
       ? ['query', 'error', 'warn'] 
       : ['error'],
   })
   
   if (process.env.NODE_ENV !== 'production') {
     globalForPrisma.prisma = prisma
   }
   
   export default prisma
   ```

5. **Crear packages/database/src/index.ts:**
   ```typescript
   // Re-export Prisma client
   export { prisma } from './client'
   export { default } from './client'
   
   // Re-export types for convenience
   export * from './generated/client'
   ```

6. **Verificar que el cliente funciona:**
   ```bash
   cd packages/database
   npx ts-node --esm -e "
     import { prisma } from './src/index.ts';
     prisma.products.findMany().then(p => console.log('Products:', p.length)).catch(console.error).finally(() => prisma.\$disconnect());
   "
   ```
  </action>
  <verify>
    - `ls packages/database/prisma/migrations/0_init/` muestra `migration.sql`
    - `ls packages/database/src/generated/client/` muestra archivos generados
    - `cat packages/database/src/client.ts | grep PrismaClient` confirma cliente
  </verify>
  <done>
    - Baseline migration creada y marcada como aplicada
    - Cliente Prisma generado
    - src/client.ts exporta prisma configurado para Supabase
    - src/index.ts re-exporta cliente y tipos
  </done>
</task>

<task type="auto">
  <name>Task 3: Migrar modelos API de raw SQL a Prisma</name>
  <files>
    apps/api/src/models/Product.js
    apps/api/src/models/User.js
    apps/api/src/models/Auth.js
    apps/api/src/models/Address.js
    apps/api/src/models/Favorites.js
    apps/api/src/config/db.js
    apps/api/package.json
  </files>
  <action>
1. **Actualizar apps/api/package.json para usar TypeScript parcialmente:**
   - Agregar a dependencies: `"@lapancomido/database": "workspace:*"`
   - Agregar a devDependencies: `"tsx": "^4.7.0"` (para ejecutar TS en Node)

2. **Migrar apps/api/src/models/Product.js a usar Prisma:**
   ```javascript
   // apps/api/src/models/Product.js
   import { prisma } from '@lapancomido/database';
   
   export const getAllProducts = async () => {
     const products = await prisma.products.findMany({
       select: {
         id: true,
         product: true,
         ingredients: true,
         price: true,
         weight: true,
         description: true,
         nutrition: true,
         available: true,
         created_at: true,
         updated_at: true,
       },
     });
     return products;
   };
   
   export const getProductById = async (id) => {
     const product = await prisma.products.findUnique({
       where: { id: parseInt(id) },
       select: {
         id: true,
         product: true,
         ingredients: true,
         price: true,
         weight: true,
         description: true,
         nutrition: true,
         available: true,
         created_at: true,
         updated_at: true,
       },
     });
     return product;
   };
   
   export const createProduct = async (productData) => {
     const product = await prisma.products.create({
       data: {
         product: productData.product,
         ingredients: productData.ingredients || null,
         price: productData.price,
         weight: productData.weight || null,
         description: productData.description || null,
         nutrition: productData.nutrition || null,
         available: productData.available ?? false,
       },
     });
     return product;
   };
   
   export const createStock = async (productId, stockValue) => {
     const stock = await prisma.stock.create({
       data: {
         id_product: parseInt(productId),
         stock: stockValue,
       },
     });
     return stock;
   };
   
   export const updateProduct = async (id, productData) => {
     const product = await prisma.products.update({
       where: { id: parseInt(id) },
       data: {
         product: productData.product,
         ingredients: productData.ingredients || null,
         price: productData.price,
         weight: productData.weight || null,
         description: productData.description || null,
         nutrition: productData.nutrition || null,
         available: productData.available,
         updated_at: new Date(),
       },
     });
     return product;
   };
   
   export const deleteProduct = async (id) => {
     const product = await prisma.products.delete({
       where: { id: parseInt(id) },
     });
     return product;
   };
   ```

3. **Migrar apps/api/src/models/User.js de forma similar:**
   - Reemplazar `db.query()` con `prisma.users.findMany()`, `prisma.users.findUnique()`, etc.
   - Mantener la misma interfaz de funciones exportadas

4. **Migrar apps/api/src/models/Auth.js:**
   - Reemplazar queries de autenticación con Prisma
   - Mantener lógica de JWT intacta

5. **Migrar otros modelos (Address.js, Favorites.js):**
   - Mismo patrón: reemplazar db.query con prisma.[model].[operation]

6. **Eliminar o deprecar apps/api/src/config/db.js:**
   - Renombrar a `db.js.deprecated` o eliminar
   - Ya no se necesita conexión directa a pg

7. **Verificar paridad de comportamiento:**
   - Probar que GET /api/products retorna mismos datos
   - Probar que POST /api/products crea correctamente
   - Probar autenticación funciona igual

IMPORTANTE: Mantener EXACTA la misma interfaz de funciones. Solo cambia la implementación interna.
  </action>
  <verify>
    - `npm run test --workspace=@lapancomido/api` pasa (si hay tests)
    - `curl http://localhost:3001/api/products` retorna productos
    - No hay imports de `../config/db` en modelos
    - Todos los modelos importan de `@lapancomido/database`
  </verify>
  <done>
    - Todos los modelos migrados de raw SQL a Prisma
    - Misma interfaz de funciones mantenida
    - db.js eliminado o deprecado
    - API funciona idénticamente con Prisma
  </done>
</task>

</tasks>

<verification>
1. `npx prisma validate` sin errores
2. `npx prisma generate` genera cliente sin errores
3. API responde a requests con datos correctos
4. Logs muestran queries Prisma (en dev mode)
5. Comparar respuesta de /api/products antes y después - debe ser idéntica
</verification>

<success_criteria>
- Schema Prisma generado por introspección de Supabase
- Baseline migration creada y marcada como aplicada
- Cliente Prisma funcional con connection pooling
- Todos los modelos API migrados a usar Prisma
- Paridad exacta de comportamiento con raw SQL
</success_criteria>

<output>
After completion, create `.planning/phases/01-fundacion-migracion-db/01-02-SUMMARY.md`
</output>
